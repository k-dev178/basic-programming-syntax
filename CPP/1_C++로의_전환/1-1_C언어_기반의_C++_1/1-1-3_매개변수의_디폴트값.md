# 매개변수에 설정하는 '디폴트 값'의 의미
앞서 함수 오버로딩에 대해서 언급하였다. 그런데 C++의 함수에는 ‘디폴트 값’을 설정할 수 있다. 여기서 말하는 ‘디폴트 값’이란 기본적으로 설정되어 있는 값을 의미한다. 일단은 이 정도만 이해하고 본론으로 들어가자.

함수의 매개변수를 다음의 형태로 선언하는 것이 가능하다.
```cpp
int MyFuncOne(int num = 7)
{
    return num + 1;
}

int MyFuncTwo(int num1 = 5, int num2 = 7)
{
    return num1 + num2;
}
```

여기서 MyFuncOne의 매개변수 선언은 다음과 같다.  
`int num = 7`  
그리고 이는 다음의 의미를 지닌다.  
“함수 호출 시 인자를 전달하지 않으면 **7이 전달된 것**으로 간주하겠다.”

따라서 다음 두 함수 호출문은 완전히 동일하다.
```cpp
MyFuncOne();   // 7이 전달된 것으로 간주
MyFuncOne(7);
```

이어서, MyFuncTwo의 매개변수 선언은 다음과 같다.  
`int num1 = 5, int num2 = 7`  
그리고 이는 다음의 의미를 지닌다.  
“함수 호출 시 인자를 전달하지 않으면 **num1에는 5**, **num2에는 7**이 전달된 것으로 간주하겠다.”

따라서 다음 두 함수 호출문은 완전히 동일하다.
```cpp
MyFuncTwo();      // 5와 7이 전달된 것으로 간주
MyFuncTwo(5, 7);
```

그럼 지금까지 설명한 내용을 바탕으로 예제를 하나 제시하겠으니, 매개변수에 디폴트 값을 지정한 결과를 확인하기 바란다.  
(**DefaultValue1.cpp 코드**)

위의 예제 11행을 통해서 다음 사실도 추가로 확인할 수 있었을 것이다.  
“매개변수에 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 **적은 수의 인자 전달이 가능하다**.”  
또한 전달되는 인자는 **왼쪽에서부터 채워지고**, 부족한 인자는 **디폴트 값으로 채워진다**.  
문장으로 정리하려다 보니 다소 길어졌는데, 이는 위 예제 11행의 실행 결과를 통해 쉽게 이해할 수 있는 내용이다.

---

# 디폴트 값은 함수의 선언 부분에만 표현하면 됩니다.
함수의 원형을 별도로 선언하는 경우, 매개변수의 디폴트 값은 **함수의 원형 선언**에만 위치시켜야 한다.  
즉, 위에서 소개한 예제 DefaultValue1.cpp는 다음과 같이 다시 작성할 수 있다.

> (DefaultValue2.cpp 코드)

위 예제의 2행은 함수의 **선언**이고, 12행은 함수의 **정의**이다. 그런데 매개변수의 디폴트 값 지정은 함수의 **선언 부분**에 위치한다. 이렇듯 함수의 선언이 별도로 필요한 경우에는 매개변수의 디폴트 값은 **함수의 선언 부분에만** 위치시켜야 한다.

디폴트 값의 선언이 함수의 선언 부분에 위치해야 하는 이유는?  
디폴트 값의 선언이 함수의 선언 부분에 위치해야 하는 이유는 조금만 생각해보면 쉽게 알 수 있다. 만약 디폴트 값의 선언이 함수의 선언 부분에 위치하지 않는다면, 예제 DefaultValue2.cpp에서 6행과 7행이 컴파일 가능하겠는가?

---

# 부분적 디폴트 값 설정
다음과 같이 정의된 함수가 있다고 가정해 보자.
```cpp
int YourFunc(int num1, int num2, int num3) { /* ... */ }
```
이러한 경우, 다음과 같이 디폴트 값을 전부 지정할 수도 있지만,
```cpp
int YourFunc(int num1 = 3, int num2 = 5, int num3 = 7) { /* ... */ }
```
다음과 같이 **일부만** 디폴트 값을 지정할 수도 있다.
```cpp
int YourFunc(int num1, int num2 = 5, int num3 = 7) { /* ... */ }
```
이렇게 일부만 디폴트 값을 지정하면, 다음 형태로도 함수 호출이 가능하다.
```cpp
YourFunc(10);      // YourFunc(10, 5, 7)
YourFunc(10, 20);  // YourFunc(10, 20, 7)
// YourFunc(10, 5, 7);
// YourFunc(10, 20, 7);
```

하지만, 다음과 같이 **오른쪽 매개변수의 디폴트 값을 비운 형태**로는 디폴트 값을 지정할 수 없다.
```cpp
int YourFunc(int num1 = 3, int num2 = 5, int num3) { /* ... */ }  // (X)
```
반드시 **오른쪽 매개변수부터** 디폴트 값을 채우는 형태로 정의해야 한다. 즉, 다음의 함수 정의는 모두 **유효**하다.
```cpp
int YourFunc(int num1, int num2, int num3 = 30) { /* ... */ }          // (O)
int YourFunc(int num1, int num2 = 20, int num3 = 30) { /* ... */ }     // (O)
int YourFunc(int num1 = 10, int num2 = 20, int num3 = 30) { /* ... */ } // (O)
```
반면 다음의 함수 정의는 모두 **유효하지 않다**.
```cpp
int WrongFunc(int num1 = 10, int num2, int num3) { /* ... */ }         // (X)
int WrongFunc(int num1 = 10, int num2 = 20, int num3) { /* ... */ }    // (X)
```

그렇다면 반드시 오른쪽부터 채울 것을 요구하는 이유는 무엇일까?  
“함수에 전달되는 인자는 **왼쪽에서 오른쪽으로** 채워지기 때문”이다. 이는 이미 알고 있는 사실이다. 이러한 특성 때문에 다음과 같이 **오른쪽부터** 채워진 함수 정의만 의미를 갖는다.
```cpp
int YourFunc(int num1, int num2, int num3 = 30) { /* ... */ }
```
위와 같이 정의된 함수를 기준으로 다음과 같이 호출하면,
```cpp
YourFunc(10, 20);   // YourFunc(10, 20, 30)
```
매개변수 `num1`과 `num2`에는 10과 20이 전달되고, `num3`에는 디폴트 값 30이 전달된다. 그럼 이번에는 다음과 같이 정의된(물론 **정의 불가능하다**) 함수를 호출한다고 가정해 보자.
```cpp
int YourFunc(int num1 = 12, int num2, int num3) { /* ... */ }  // (X)
```
이 함수의 매개변수에 지정되어 있는 디폴트 값 12가 의미를 가지려면, `num1`이 아닌 `num2`와 `num3`에만 인자를 전달할 수 있어야 한다. 그런데 그것이 가능한가? **불가능하다!** 함수에 전달되는 인자가 **왼쪽에서 오른쪽으로** 채워지기 때문이다.  
자, 그럼 예제를 하나 더 소개하면서 매개변수의 디폴트 값 지정에 대한 설명을 마무리하겠다.

> (DefaultValue3.cpp 코드)
